---
title: "UA ALM 20260210"
format:
  html:
    toc: true
    number-sections: false
    colorlinks: true
    embed-resources: true
    html-math-method: webtex
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
    geometry:
      - left=0.5in
      - right=0.5in
      - top=0.5in
      - bottom=0.5in
    papersize: letter
    fontsize: 11pt
---

```{python}
# | label: setup
from datetime import date
import logging
import numpy as np
import polars as pl
import plotly.graph_objects as go
import plotly.io as pio
import os
from pathlib import Path
import sys

from great_tables import GT, style, loc

sys.path.insert(0, str((Path.cwd().parent) / "src"))
from alm.asset import Bond, PrivateCredit
from alm.liability import SPIA, Term, WL, FIA, qx_from_table
from alm.read import get_2012_iam_table, update_credit_spreads
from alm.core import (
    Block,
    InterestRateSwap,
    SAA,
    default_saa,
    spia_saa,
    dv01,
    dollar_convexity,
    immunize,
    irr,
)
from alm import plot

logger = logging.getLogger(__name__)

pdf_bool = os.environ.get("QUARTO_PROJECT_OUTPUT_FORMAT") == "pdf"
if pdf_bool:
    pio.renderers.default = "png"
else:
    pio.renderers.default = "notebook_connected+vscode"

update_credit_spreads()

DISCOUNT_RATE = 0.04

BRAND = "#2563eb"  # blue from palette


def styled_gt(df, title=None):
    """GT table with branded header and styled column labels."""
    gt = GT(df)
    if title:
        gt = gt.tab_header(title)
    return gt.tab_options(
        heading_background_color=BRAND,
        column_labels_background_color="#dbeafe",
        column_labels_font_weight="bold",
    ).tab_style(
        style=style.text(color="white", weight="bold"),
        locations=loc.header(),
    )


today = date.today()
logger.info("DATE: %s", today)
logger.info("AUTHOR: Brennen Slaney, FSA")
logger.info("SOURCE: https://github.com/realslimslaney/ALM")
```

# 1. Introduction
{{< include ../docs/brennen-slaney.md >}}


# 2. Building Blocks of ALM

## Insurance Company Balance Sheet
An insurance company's balance sheet is made up of three key components:

1. **Assets** — The investments the company holds (bonds, mortgages, private credit)

2. **Liabilities** — The obligations the company owes to policyholders (annuities, life insurance)

3. **Equity (Surplus)** — The residual value that belongs to shareholders after settling liabilities with assets

![Balance Sheet](../images/balance_sheet.png){width=80%}

## Assets

**Assets are the money you have.** Most of it is invested in safe, predictable instruments:

- Treasuries (government bonds — safe, liquid, benchmark yield)
- Highly rated corporate bonds
- Mortgage-Backed Securities
- Private credit (higher yield for illiquidity & credit risk)


The goal is **positive expected yield with lower variance**. Regulators enforce capital requirements and "score" the safety of assets. Investment teams manage the portfolio, but actuaries are often involved.

For this presentation we'll use the following sample portfolio:

```{python}
# | label: assets
assets = [
    Bond(
        face_value=8_000_000, coupon_rate=0.0390, maturity=2, frequency=2, rating="AAA"
    ),
    Bond(
        face_value=10_000_000,
        coupon_rate=0.0425,
        maturity=5,
        frequency=2,
        rating="A",
        credit_spread=0.0027,
    ),
    PrivateCredit(
        face_value=5_000_000,
        maturity=7,
        risk_free_rate=0.04,
        credit_spread=0.03,
        illiquidity_spread=0.020,
        other_spread=0.005,
        rating="BB",
    ),
    Bond(
        face_value=15_000_000,
        coupon_rate=0.0400,
        maturity=10,
        frequency=2,
        rating="AAA",
    ),
    Bond(
        face_value=8_000_000, coupon_rate=0.0420, maturity=20, frequency=2, rating="AA"
    ),
]

# Purchase prices slightly off par so IRR differs from coupon rate
purchase_prices = [
    7_950_000,  # 2Y UST — slight discount to $8M par
    10_175_000,  # 5Y Corp A — slight premium to $10M par
    4_850_000,  # 7Y PC BB — slight discount to $5M par
    15_225_000,  # 10Y UST — slight premium to $15M par
    7_880_000,  # 20Y AA — slight discount to $8M par
]


# Compute IRR from actual cashflows: -purchase_price at t=0, then periodic cashflows
def bond_irr(asset, purchase_price: float) -> float:
    """Compute annualised IRR from purchase price and cashflow schedule."""
    cf = asset.cashflows()
    freq = asset.frequency
    # Build per-period cashflows with purchase price as outflow
    period_cfs = [-purchase_price] + cf["total"].to_list()
    # Solve for periodic IRR then annualise
    periodic_r = irr(period_cfs)
    return periodic_r * freq  # simple annualisation consistent with coupon convention


asset_irrs = [bond_irr(a, pp) for a, pp in zip(assets, purchase_prices)]

asset_summary = pl.DataFrame(
    {
        "instrument": [
            "$8M UST 2Y",
            "$10M Corp A 5Y",
            "$5M PC BB 7Y",
            "$15M UST 10Y",
            "$8M AA 20Y",
        ],
        "face_value": [a.face_value for a in assets],
        "purchase_price": purchase_prices,
        "coupon_rate": [
            assets[0].coupon_rate,
            assets[1].coupon_rate,
            assets[2].total_yield,
            assets[3].coupon_rate,
            assets[4].coupon_rate,
        ],
        "irr": asset_irrs,
        "maturity": [2, 5, 7, 10, 20],
    }
)
styled_gt(asset_summary, "Sample Asset Portfolio").fmt_currency(
    ["face_value", "purchase_price"], decimals=0
).fmt_percent(["coupon_rate", "irr"], decimals=2).fmt_number("maturity", decimals=0)
```

```{python}
# | label: asset-portfolio-chart
fig = plot.bar_chart(
    asset_summary,
    x="instrument",
    y="face_value",
    title="Portfolio Composition by Face Value",
    xlab="Instrument",
    ylab="Face Value",
    yformat="$",
)
fig.show()
```

## Liabilities

**Liabilities are money you owe.** Nearly every insurance contract comes with a liability for the insurer. The timing and amount can be known or unknown:

- **Known** — Annuity Certain (fixed schedule of payments)
- **Unknown** — Term Life (death benefit contingent on mortality)
- **Market-linked** — Fixed Indexed Annuity (account value credited based on an index, with floor and cap guarantees)

**Actuaries are the liability experts!**

```{python}
# | label: liabilities
mortality = get_2012_iam_table()

# Whole Life block: $10M face value, net level premium via equivalence principle
qx_wl = qx_from_table(mortality, age=45, sex="male")
wl = WL.from_face(face_value=10_000_000, qx=qx_wl, discount_rate=DISCOUNT_RATE, age=45)

# SPIA block: $3M annual payout, fair single premium = PV of expected payouts
qx_spia = qx_from_table(mortality, age=65, sex="female")
spia = SPIA.from_payout(annual_payout=3_000_000, qx=qx_spia, discount_rate=DISCOUNT_RATE, age=65)

# FIA block: $3M single premium, 10-year deferred, male age 55
qx_fia = qx_from_table(mortality, age=55, sex="male")
fia_index_rates = [-0.02, 0.06, 0.12, 0.04, -0.05, 0.10, 0.03, 0.08, -0.01, 0.07]
fia = FIA(
    premium=3_000_000, term=10, qx=qx_fia,
    floor=0.00, cap=0.08, participation_rate=0.80, age=55,
)


def fia_pv_func(r: float) -> float:
    """FIA present value as a function of discount rate only."""
    return fia.present_value(fia_index_rates, r)


liab_summary = pl.DataFrame(
    {
        "product": ["Whole Life", "SPIA", "FIA"],
        "amount": [wl.face_value, spia.annual_payout, fia.premium],
        "amount_label": ["face value", "annual payout", "single premium"],
        "premium": [wl.annual_premium, spia.premium, fia.premium],
        "premium_label": ["annual", "single", "single"],
        "age": [wl.age, spia.age, fia.age],
    }
)
styled_gt(liab_summary, "Liability Summary").fmt_currency(
    ["amount", "premium"], decimals=0
).fmt_number("age", decimals=0)
```

## Equity

**Equity = Assets - Liabilities**

- Without equity, a company will be liquidated by regulators
- Stability is important — you don't want drastic swings
- Excess capital funds expansion, retained earnings, and dividends
- When you buy a stock, you are taking a stake in their equity. $0 Equity = $0 Stock Price

::: {.callout-tip}
## Example
If Assets = $50M and Liabilities = $40M, then Equity = $10M.
That $10M funds new projects, dividends, bonuses, regulatory requirements.
:::


# 3. Strategic Asset Allocation

**Strategic Asset Allocation (SAA)** determines how an insurer divides its investment
portfolio across asset classes (government bonds, corporate bonds, mortgages, private credit, etc.).

- SAA is the **first and most important** decision in investment management — it drives most of the portfolio's risk and return
- Insurers set SAA targets at the **block level**: different liability types get different allocations
- The goal is to earn enough yield to meet policyholder obligations while staying within risk limits
- Regulators score asset quality (NAIC designations), so SAA must also satisfy **capital requirements**

```{python}
# | label: saa-example
saa = default_saa()
saa_df = pl.DataFrame({
    "asset_class": list(saa.weights.keys()),
    "weight": list(saa.weights.values()),
})
styled_gt(saa_df, "Default SAA Weights").fmt_percent("weight", decimals=0)
```

## Matching Allocation to Liability Duration

Different liability types have different duration profiles.
A smart insurer matches its **asset allocation** to the duration of the liabilities it backs.

## Two Blocks of Business

We build two blocks:

- **Short-duration** (Term Life, ages 30–50): ~20-year policies, payouts concentrated in early years
- **Long-duration** (SPIA, ages 60–75): lifetime payouts, cashflows stretch 30+ years

```{python}
# | label: block-saa-setup
short_saa = SAA(weights={
    "govt_bonds": 0.55,
    "corp_bonds": 0.25,
    "mortgages": 0.15,
    "private_credit": 0.05,
})

long_saa = SAA(weights={
    "govt_bonds": 0.25,
    "corp_bonds": 0.45,
    "mortgages": 0.20,
    "private_credit": 0.10,
})

saa_compare = pl.DataFrame({
    "asset_class": list(short_saa.weights.keys()),
    "short_duration_block": list(short_saa.weights.values()),
    "long_duration_block": list(long_saa.weights.values()),
})
styled_gt(saa_compare, "SAA by Liability Duration").fmt_percent(
    ["short_duration_block", "long_duration_block"], decimals=0
)
```

**Why the difference?**

- Short-duration liabilities need **liquidity** and **safety** → more government bonds
- Long-duration liabilities can tolerate **longer tenor** and **credit risk** → more corporate bonds
- The spread earned on longer-dated corporate bonds compensates for additional credit and duration risk

```{python}
# | label: block-generation
short_block = Block(
    liability_type="Term",
    saa=short_saa,
    total_liability_amount=20_000_000,
    mortality_table=mortality,
    age_range=(30, 50),
    discount_rate=DISCOUNT_RATE,
    n_policies=200,
    seed=42,
)
_ = short_block.generate_policies()
_ = short_block.generate_assets()

long_block = Block(
    liability_type="SPIA",
    saa=long_saa,
    total_liability_amount=20_000_000,
    mortality_table=mortality,
    age_range=(60, 75),
    discount_rate=DISCOUNT_RATE,
    n_policies=200,
    seed=42,
)
_ = long_block.generate_policies()
_ = long_block.generate_assets()
```

## Cashflow Comparison

*Note: These cashflows assume no reinvestment of asset proceeds as a simplifying assumption. In practice, maturing bonds and coupon income would be reinvested, smoothing asset cashflows over time. This leads to higher asset cashflows in earlier time periods than a fully built model would show.*

```{python}
# | label: block-short-cf
fig_short = short_block.plot_cashflows()
fig_short.show()
```

```{python}
# | label: block-long-cf
fig_long = long_block.plot_cashflows()
fig_long.show()
```

## IRR Comparison

The **Internal Rate of Return (IRR)** on the asset side tells us the expected yield
the insurer earns on each block. Longer blocks with more private credit should
earn a higher return — the reward for accepting illiquidity.

```{python}
# | label: block-irr
short_asset_cf = short_block.asset_cashflows()
long_asset_cf = long_block.asset_cashflows()

# Build IRR cashflows: initial premium outflow + asset inflows by year
short_irr_cfs = [-short_block.premium] + short_asset_cf["cashflow"].to_list()
long_irr_cfs = [-long_block.premium] + long_asset_cf["cashflow"].to_list()

short_irr = irr(short_irr_cfs)
long_irr = irr(long_irr_cfs)

irr_df = pl.DataFrame({
    "block": ["Short-Duration (Term)", "Long-Duration (SPIA)"],
    "saa_pc_weight": [short_saa.weights["private_credit"], long_saa.weights["private_credit"]],
    "irr": [short_irr, long_irr],
})
styled_gt(irr_df, "Asset IRR by Block").fmt_percent(
    ["saa_pc_weight", "irr"], decimals=2
)
```

::: {.callout-tip}
## Key Insight
The long-duration block earns a higher IRR because it allocates more to corporate bonds
and private credit. The credit spread and illiquidity premium are real sources of return — but only
appropriate when the liabilities are long enough to wait.
:::


# 4. Cashflows from Assets and Liabilities

What do these things actually look like?

## Asset Cashflows

```{python}
# | label: asset-cashflows
# Show cashflows for the 2Y Treasury (4 semi-annual periods — a complete bond lifecycle)
ust_2y = assets[0]

styled_gt(
    ust_2y.cashflows(), "$8M UST 2Y — All Cashflows"
).fmt_currency(
    ["coupon", "principal", "total"], decimals=0
)
```

```{python}
# | label: asset-cashflow-metrics
logger.info("$8M UST 2Y: PV @ %s = $%s", f"{DISCOUNT_RATE:.0%}", f"{ust_2y.present_value(DISCOUNT_RATE):,.0f}")
logger.info("$8M UST 2Y: Duration = %.2f years", ust_2y.duration(DISCOUNT_RATE))
```

::: {layout-ncol=2}

```{python}
# | label: asset-cashflow-bar-treasury
# Bar chart: 2Y Treasury — coupon vs principal by period (short-maturity bullet bond)
cf_2y = ust_2y.cashflows()

fig = go.Figure()
fig.add_trace(go.Bar(
    x=cf_2y["period"].to_list(), y=cf_2y["coupon"].to_list(),
    name="Coupon", marker_color=plot.PALETTE[0],
))
fig.add_trace(go.Bar(
    x=cf_2y["period"].to_list(), y=cf_2y["principal"].to_list(),
    name="Principal", marker_color=plot.PALETTE[1],
))
fig.update_layout(
    template="plotly_white",
    title="$8M UST 2Y — Cashflows by Period",
    xaxis_title="Period (semi-annual)", yaxis_title="Cashflow",
    yaxis_tickprefix="$", yaxis_tickformat=",.0f",
    barmode="stack",
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    margin=dict(l=60, r=30, t=60, b=50),
)
fig.show()
```

```{python}
# | label: asset-cashflow-bar-pc
# Bar chart: 7Y Private Credit — coupon vs principal by year (higher yield, longer tenor)
pc_7y = assets[2]
cf_pc = pc_7y.cashflows()

# Aggregate to annual
cf_pc_annual = (
    cf_pc.with_columns(((pl.col("period") - 1) // pc_7y.frequency + 1).alias("year"))
    .group_by("year").agg(
        pl.col("coupon").sum(),
        pl.col("principal").sum(),
    ).sort("year")
)

fig = go.Figure()
fig.add_trace(go.Bar(
    x=cf_pc_annual["year"].to_list(), y=cf_pc_annual["coupon"].to_list(),
    name="Coupon", marker_color=plot.PALETTE[0],
))
fig.add_trace(go.Bar(
    x=cf_pc_annual["year"].to_list(), y=cf_pc_annual["principal"].to_list(),
    name="Principal", marker_color=plot.PALETTE[1],
))
fig.update_layout(
    template="plotly_white",
    title="$5M PC BB 7Y — Annual Cashflows",
    xaxis_title="Year", yaxis_title="Cashflow",
    yaxis_tickprefix="$", yaxis_tickformat=",.0f",
    barmode="stack",
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    margin=dict(l=60, r=30, t=60, b=50),
)
fig.show()
```

:::

Each bond pays level coupons then returns full principal at maturity — the spike at the end.
The private credit instrument earns a **higher coupon** (from credit, illiquidity, and other spreads)
relative to its face value, compensating the investor for additional risk and illiquidity.

## Liability Cashflows

```{python}
# | label: liability-cashflows
wl_cf = wl.cashflows()
# Find the peak expected_benefit month and grab 5 months around it
peak_idx = wl_cf["expected_benefit"].arg_max()
peak_start = max(0, peak_idx - 2)
peak_slice = wl_cf.slice(peak_start, 5)
wl_display = (
    pl.concat([wl_cf.head(5), peak_slice])
    .with_columns(pl.col("period").alias("month"))
    .select("month", "survival_prob", "expected_premium", "expected_benefit", pl.col("net_cashflow").alias("expected_total_cashflow"))
)
styled_gt(
    wl_display, "Whole Life — Monthly Cashflows (first 5 & peak liability months)"
).fmt_currency(["expected_premium", "expected_benefit", "expected_total_cashflow"], decimals=0).fmt_number(
    "survival_prob", decimals=4
).fmt_number("month", decimals=0)
```

```{python}
# | label: liability-cashflows-spia
spia_cf = spia.cashflows()
spia_display = spia_cf.head(12).with_columns(
    pl.col("period").alias("month")
).select("month", "survival_prob", "payout", "expected_payout")
styled_gt(
    spia_display, "SPIA — Expected Monthly Cashflows (first 12 months)"
).fmt_currency(["payout", "expected_payout"], decimals=0).fmt_number(
    "survival_prob", decimals=4
).fmt_number("month", decimals=0)
```

```{python}
# | label: liability-cashflows-fia
fia_cf = fia.cashflows(fia_index_rates)
fia_av = fia.account_values(fia_index_rates)

# Join market return and credited rate into the cashflow table
fia_display = (
    fia_cf.join(
        fia_av.filter(pl.col("year") > 0).select("year", "index_rate", "credited_rate"),
        on="year",
        how="left",
    )
    .select(
        "year",
        pl.col("index_rate").alias("market_return"),
        pl.col("credited_rate").alias("fia_return"),
        "account_value", "survival_prob",
        "expected_death_benefit", "expected_maturity_benefit",
        pl.col("net_cashflow").alias("expected_total_cashflow"),
    )
)

styled_gt(
    fia_display,
    "FIA — Annual Expected Cashflows ($3M Premium, 10-Year, Floor 0%, Cap 8%)",
).fmt_currency(
    ["account_value", "expected_death_benefit", "expected_maturity_benefit", "expected_total_cashflow"],
    decimals=0,
).fmt_percent(
    ["market_return", "fia_return"], decimals=1,
).fmt_number("survival_prob", decimals=4).fmt_number("year", decimals=0)
```

::: {layout-ncol=2}

```{python}
# | label: liability-cashflow-chart-wl
# Aggregate WL to annual
wl_annual = wl_cf.group_by((pl.col("period") - 1) // wl.frequency).agg(
    pl.col("year").max().alias("year"),
    pl.col("net_cashflow").sum().alias("expected_total_cashflow"),
)
fig = plot.line_chart(
    wl_annual.sort("year").head(40),
    x="year",
    y="expected_total_cashflow",
    title="WL — Annual Expected Total Cashflow",
    xlab="Year",
    ylab="Expected Total Cashflow",
    yformat="$",
)
fig.show()
```

```{python}
# | label: liability-cashflow-chart-spia
# Aggregate SPIA to annual
spia_annual = spia_cf.group_by((pl.col("period") - 1) // spia.frequency).agg(
    pl.col("year").max().alias("year"),
    pl.col("expected_payout").sum().alias("expected_payout"),
)
fig = plot.line_chart(
    spia_annual.sort("year").head(40),
    x="year",
    y="expected_payout",
    title="SPIA — Annual Expected Payouts",
    xlab="Year",
    ylab="Annual Payout",
    yformat="$",
)
fig.show()
```

:::

```{python}
# | label: liability-cashflow-chart-fia
fig = plot.bar_chart(
    fia_cf.select(
        "year",
        pl.col("expected_death_benefit"),
        pl.col("expected_maturity_benefit"),
    ),
    x="year",
    y=["expected_death_benefit", "expected_maturity_benefit"],
    title="FIA — Annual Expected Cashflows",
    xlab="Year",
    ylab="Expected Cashflow",
    yformat="$",
    barmode="stack",
)
fig.show()
```

## Equity (Surplus) View

```{python}
# | label: equity-view
total_asset_pv = sum(a.present_value(DISCOUNT_RATE) for a in assets)
wl_pv = wl.present_value(DISCOUNT_RATE)
spia_pv = spia.present_value(DISCOUNT_RATE)
fia_pv = fia_pv_func(DISCOUNT_RATE)
total_liab_pv = wl_pv + spia_pv + fia_pv

equity_df = pl.DataFrame({
    "component": ["Assets", "Liabilities", "Surplus (Equity)"],
    "present_value": [total_asset_pv, total_liab_pv, total_asset_pv - total_liab_pv],
})
styled_gt(equity_df, "Balance Sheet — Present Values").fmt_currency("present_value", decimals=0)
```

```{python}
# | label: balance-sheet-chart
fig = plot.bar_chart(
    equity_df,
    x="component",
    y="present_value",
    title="Balance Sheet at 4% Discount Rate",
    xlab="",
    ylab="Present Value",
    yformat="$",
)
fig.show()
```




# 5. Key Mathematical Concepts

How do actuaries measure the financial risk of interest rates?

## Duration

**Duration** is the time-weighted average of the present value of cashflows.
It measures a bond's sensitivity to interest rate changes and helps us
linearly estimate price changes from rate movements.

$$
D = \frac{1}{P} \sum_{t=1}^{n} \frac{t}{f} \cdot \frac{CF_t}{(1 + y/f)^t}
$$

```{python}
# | label: duration-example
bond_example = Bond(face_value=100, coupon_rate=0.02, maturity=30, frequency=2)
base_rate = 0.02
dur = bond_example.duration(base_rate)
logger.info("30Y 2%% semi-annual bond: Duration = %.2f years", dur)
```

## Convexity

**Convexity** captures the **second-order** (curvature) effect of yield changes on price.
Duration alone gives a *linear* approximation — it assumes the price-yield
relationship is a straight line. But the real relationship is curved (convex),
and convexity captures that curvature.

**Why it matters:** For large rate moves, duration alone underestimates the
price gain when rates fall and overestimates the price loss when rates rise.
Convexity corrects this bias.

### Price Change via Taylor Expansion

The present value $P$ of a fixed cashflow stream is a function of yield $y$.
Expanding $P(y + \Delta y)$ around $y$ using a Taylor series:

$$
P(y + \Delta y) \approx P(y) + \frac{dP}{dy}\Delta y + \frac{1}{2}\frac{d^2P}{dy^2}(\Delta y)^2
$$

Dividing both sides by $P$:

$$
\frac{\Delta P}{P} \approx \underbrace{-D_{\text{mod}} \cdot \Delta y}_{\text{1st order: Duration}} + \underbrace{\frac{1}{2} \cdot C \cdot (\Delta y)^2}_{\text{2nd order: Convexity}}
$$

where:

- **Modified Duration** $D_{\text{mod}} = -\frac{1}{P}\frac{dP}{dy}$ — first derivative of price w.r.t. yield, scaled by price
- **Convexity** $C = \frac{1}{P}\frac{d^2P}{dy^2}$ — second derivative of price w.r.t. yield, scaled by price

The closed-form expression for convexity of a bond with periodic cashflows is:

$$
C = \frac{1}{P \cdot f^2} \sum_{t=1}^{n} \frac{t(t+1) \cdot CF_t}{(1 + y/f)^{t+2}}
$$

```{python}
# | label: convexity-example
conv = bond_example.convexity(base_rate)
mod_dur = dur / (1 + base_rate / 2)

logger.info("Modified Duration: %.2f", mod_dur)
logger.info("Convexity:         %.2f", conv)

# Price change estimates across a continuous range of shocks
shock_range = [s / 1000 for s in range(-30, 31)]
approx_rows = []
pv_base = bond_example.present_value(base_rate)
for s in shock_range:
    actual = (bond_example.present_value(base_rate + s) - pv_base) / pv_base
    dur_only = -mod_dur * s
    dur_conv = -mod_dur * s + 0.5 * conv * s**2
    approx_rows.append({
        "rate_shock": s,
        "actual": actual,
        "duration_only": dur_only,
        "duration_convexity": dur_conv,
    })

approx_df = pl.DataFrame(approx_rows)
```

::: {layout-ncol=2}

```{python}
# | label: duration-approx-chart
fig = go.Figure()
fig.add_trace(go.Scatter(
    x=approx_df["rate_shock"].to_list(), y=approx_df["actual"].to_list(),
    mode="lines", name="actual", line=dict(color="#2563eb"),
))
fig.add_trace(go.Scatter(
    x=approx_df["rate_shock"].to_list(), y=approx_df["duration_only"].to_list(),
    mode="lines", name="duration estimate", line=dict(color="#dc2626", dash="dash"),
))
fig.update_layout(
    template="plotly_white", title="Actual vs Duration Estimate",
    xaxis_title="Rate Shock", yaxis_title="% Price Change",
    xaxis_tickformat=".1%", yaxis_tickformat=".0%",
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    margin=dict(l=60, r=30, t=60, b=50),
)
fig.show()
```

```{python}
# | label: convexity-approx-chart
fig = go.Figure()
fig.add_trace(go.Scatter(
    x=approx_df["rate_shock"].to_list(), y=approx_df["actual"].to_list(),
    mode="lines", name="actual", line=dict(color="#2563eb"),
))
fig.add_trace(go.Scatter(
    x=approx_df["rate_shock"].to_list(), y=approx_df["duration_convexity"].to_list(),
    mode="lines", name="duration + convexity", line=dict(color="#16a34a", dash="dash"),
))
fig.update_layout(
    template="plotly_white", title="Actual vs Duration + Convexity",
    xaxis_title="Rate Shock", yaxis_title="% Price Change",
    xaxis_tickformat=".1%", yaxis_tickformat=".0%",
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    margin=dict(l=60, r=30, t=60, b=50),
)
fig.show()
```

:::

## DV01 (Dollar Value of a Basis Point)

The dollar change in value for a 1 bps parallel shift in the yield curve.
This tells us how much money we expect our portfolio to move from a 1 bps shift.

$$
\text{DV01} = \frac{PV(y - 0.0001) - PV(y + 0.0001)}{2}
$$

```{python}
# | label: dv01-example
dv01_df = pl.DataFrame(
    {
        "instrument": asset_summary["instrument"].to_list(),
        "dv01": [dv01(a.present_value, DISCOUNT_RATE) for a in assets],
    }
)
styled_gt(dv01_df, "DV01 by Instrument").fmt_currency("dv01", decimals=0)
```

```{python}
# | label: dv01-chart
fig = plot.bar_chart(
    dv01_df,
    x="instrument",
    y="dv01",
    title="DV01 by Instrument",
    xlab="",
    ylab="DV01",
    yformat="$",
)
fig.show()
```

## Immunization (Preview)

::: {.callout-important}
## Redington Immunization Conditions
Immunization protects a portfolio's ability to meet liabilities against interest rate movements:

1. **PV Match:** PV(Assets) = PV(Liabilities)
2. **Duration Match:** Duration(Assets) = Duration(Liabilities)
3. **Convexity Condition:** Convexity(Assets) >= Convexity(Liabilities)
:::


# 6. Sensitivity to Rate Shocks

What happens when interest rates move?

```{python}
# | label: rate-shocks
shocks = [-0.01, 0.0, 0.01, 0.02]

rows = []
for shock in shocks:
    r = DISCOUNT_RATE + shock
    pv_a = sum(a.present_value(r) for a in assets)
    pv_l = wl.present_value(r) + spia.present_value(r) + fia.present_value(fia_index_rates, r)
    equity = pv_a - pv_l
    rows.append({
        "rate_shock": f"{shock:+.0%}",
        "discount_rate": f"{r:.1%}",
        "pv_assets": pv_a,
        "pv_liabilities": pv_l,
        "equity": equity,
    })

shock_df = pl.DataFrame(rows)
styled_gt(shock_df, "Present Values Under Rate Shocks").fmt_currency(
    ["pv_assets", "pv_liabilities", "equity"], decimals=0
)
```

```{python}
# | label: rate-shock-chart
fig = plot.bar_chart(
    shock_df,
    x="rate_shock",
    y=["pv_assets", "pv_liabilities"],
    title="PV of Assets vs Liabilities Under Rate Shocks",
    xlab="Rate Shock",
    ylab="Present Value",
    yformat="$",
    barmode="group",
)
fig.show()
```

```{python}
# | label: equity-shock-chart
fig = plot.bar_chart(
    shock_df,
    x="rate_shock",
    y="equity",
    title="Equity (Surplus) Under Rate Shocks",
    xlab="Rate Shock",
    ylab="Equity",
    yformat="$",
)
fig.show()
```

```{python}
# | label: pv-sensitivity-curves
# Continuous PV sensitivity across a wider rate range
rate_range = [r / 1000 for r in range(10, 81)]
pv_curve_rows = []
for r in rate_range:
    pv_a = sum(a.present_value(r) for a in assets)
    pv_l = wl.present_value(r) + spia.present_value(r) + fia.present_value(fia_index_rates, r)
    pv_curve_rows.append({"discount_rate": r, "pv_assets": pv_a, "pv_liabilities": pv_l})

pv_curve_df = pl.DataFrame(pv_curve_rows)
fig = plot.line_chart(
    pv_curve_df,
    x="discount_rate",
    y=["pv_assets", "pv_liabilities"],
    title="PV Sensitivity to Interest Rates",
    xlab="Discount Rate",
    ylab="Present Value",
    yformat="$",
    xformat="%",
)
fig.show()
```

::: {.callout-warning}
## Key Observation
Notice how assets and liabilities respond **differently** to rate changes.
This mismatch is the core problem ALM solves.
:::


# 7. Duration Hedging with Swaps

::: {.callout-tip}
## SAA Is the First Line of Defence
If your SAA produces an asset portfolio whose **duration and convexity** already closely match your liabilities, the residual interest-rate risk is small.
In that world you need **fewer hedge trades** (and smaller notionals) to close the gap.

- A well-matched SAA → small duration gap → a single swap may suffice
- A poorly-matched SAA → large duration gap → many swaps, higher cost, more operational risk

The hedging techniques below deal with whatever mismatch remains **after** the SAA has done its job.
:::

## Interest Rate Swaps

A plain-vanilla **interest rate swap** exchanges fixed payments for floating payments.
Swaps adjust portfolio duration without buying or selling bonds:

- **Receive-fixed** adds duration (like buying a bond)
- **Pay-fixed** removes duration (like selling a bond)

::: {.callout-note}
## Why Do Swaps Change Duration?

Think of an interest rate swap as two bonds packaged together:

| Position | Fixed Leg | Floating Leg | Net Duration |
|---|---|---|---|
| **Receive-fixed** | Long a fixed-rate bond (high duration) | Short a floating-rate note (≈ 0 duration) | **Positive** — adds duration |
| **Pay-fixed** | Short a fixed-rate bond (high duration) | Long a floating-rate note (≈ 0 duration) | **Negative** — removes duration |

A **floating-rate note** resets its coupon at each payment date, so its price barely moves when rates change (duration ≈ 0). A **fixed-rate bond** has locked-in coupons, so its price is highly sensitive to rates (duration > 0).

When you **receive fixed**, you are economically long the fixed-rate bond — so you inherit its duration. When you **pay fixed**, you are economically short the fixed-rate bond — so you remove that duration from your portfolio.
:::

```{python}
# | label: swap-example
swap_5y = InterestRateSwap(notional=10_000_000, fixed_rate=0.04, tenor=5, pay_fixed=False)
swap_10y = InterestRateSwap(notional=10_000_000, fixed_rate=0.04, tenor=10, pay_fixed=False)

flat_floats_5 = [0.04] * swap_5y.n_periods
flat_floats_10 = [0.04] * swap_10y.n_periods

swap_df = pl.DataFrame({
    "swap": ["5Y Receive-Fixed", "10Y Receive-Fixed"],
    "notional": [swap_5y.notional, swap_10y.notional],
    "dv01": [
        swap_5y.dv01(flat_floats_5, DISCOUNT_RATE),
        swap_10y.dv01(flat_floats_10, DISCOUNT_RATE),
    ],
})
styled_gt(swap_df, "Swap DV01").fmt_currency(["notional", "dv01"], decimals=0)
```

## Duration Gap Analysis

```{python}
# | label: duration-gap
asset_dv01 = sum(dv01(a.present_value, DISCOUNT_RATE) for a in assets)
liab_dv01 = (
    dv01(wl.present_value, DISCOUNT_RATE)
    + dv01(spia.present_value, DISCOUNT_RATE)
    + dv01(fia_pv_func, DISCOUNT_RATE)
)

gap_df = pl.DataFrame({
    "component": ["Assets", "Liabilities", "Gap (L - A)"],
    "dv01": [asset_dv01, liab_dv01, liab_dv01 - asset_dv01],
})
styled_gt(gap_df, "Duration Gap Analysis").fmt_currency("dv01", decimals=0)
```


# 8. Immunization

Immunization matches **both** duration and convexity to protect surplus against rate movements.

We solve a 2x2 system using two hedging instruments (e.g. a 5Y and 10Y swap):

$$
\begin{bmatrix}
\text{DV01}_1 & \text{DV01}_2 \\
DC_1 & DC_2
\end{bmatrix}
\begin{bmatrix}
n_1 \\ n_2
\end{bmatrix}
=
\begin{bmatrix}
\Delta\text{DV01} \\
\Delta DC
\end{bmatrix}
$$

where $DC$ denotes dollar convexity.

```{python}
# | label: immunization
asset_dc = sum(dollar_convexity(a.present_value, DISCOUNT_RATE) for a in assets)
liab_dc = (
    dollar_convexity(wl.present_value, DISCOUNT_RATE)
    + dollar_convexity(spia.present_value, DISCOUNT_RATE)
    + dollar_convexity(fia_pv_func, DISCOUNT_RATE)
)

dd_gap = liab_dv01 - asset_dv01
dc_gap = liab_dc - asset_dc

imm_gap_df = pl.DataFrame({
    "metric": ["Dollar Duration (DV01)", "Dollar Convexity"],
    "gap": [dd_gap, dc_gap],
})
styled_gt(imm_gap_df, "Gaps to Close").fmt_currency("gap", decimals=0)
```

```{python}
# | label: immunization-solve
# Per-unit sensitivities — bump floating rates with discount rate (parallel shift)
dd_5y = swap_5y.dv01(flat_floats_5, DISCOUNT_RATE) / swap_5y.notional
dc_5y = dollar_convexity(
    lambda r: swap_5y.present_value([r] * swap_5y.n_periods, r), DISCOUNT_RATE
) / swap_5y.notional
dd_10y = swap_10y.dv01(flat_floats_10, DISCOUNT_RATE) / swap_10y.notional
dc_10y = dollar_convexity(
    lambda r: swap_10y.present_value([r] * swap_10y.n_periods, r), DISCOUNT_RATE
) / swap_10y.notional

n1, n2 = immunize(dd_gap, dc_gap, dd_5y, dc_5y, dd_10y, dc_10y)

hedge_df = pl.DataFrame({
    "instrument": ["5Y Swap", "10Y Swap"],
    "notional": [n1, n2],
    "direction": ["Pay-fixed" if n1 < 0 else "Receive-fixed", "Pay-fixed" if n2 < 0 else "Receive-fixed"],
})
styled_gt(hedge_df, "Immunization Hedge Notionals").fmt_currency("notional", decimals=0)
```

```{python}
# | label: immunization-verify
# Verify: re-run rate shocks with the hedge in place
hedge_5y = InterestRateSwap(notional=abs(n1), fixed_rate=0.04, tenor=5, pay_fixed=(n1 < 0))
hedge_10y = InterestRateSwap(notional=abs(n2), fixed_rate=0.04, tenor=10, pay_fixed=(n2 < 0))

rows_hedged = []
for shock in shocks:
    r = DISCOUNT_RATE + shock
    pv_a = sum(a.present_value(r) for a in assets)
    floats_5 = [0.04 + shock] * hedge_5y.n_periods
    floats_10 = [0.04 + shock] * hedge_10y.n_periods
    pv_a += hedge_5y.present_value(floats_5, r)
    pv_a += hedge_10y.present_value(floats_10, r)
    pv_l = wl.present_value(r) + spia.present_value(r) + fia.present_value(fia_index_rates, r)
    rows_hedged.append({
        "rate_shock": f"{shock:+.0%}",
        "equity_unhedged": rows[shocks.index(shock)]["equity"],
        "equity_hedged": pv_a - pv_l,
    })

hedged_df = pl.DataFrame(rows_hedged)
styled_gt(hedged_df, "Equity: Unhedged vs Immunized").fmt_currency(
    ["equity_unhedged", "equity_hedged"], decimals=0
)
```

```{python}
# | label: immunization-chart
fig = plot.bar_chart(
    hedged_df,
    x="rate_shock",
    y=["equity_unhedged", "equity_hedged"],
    title="Equity Stability: Unhedged vs Immunized",
    xlab="Rate Shock",
    ylab="Equity",
    yformat="$",
    barmode="group",
)
fig.show()
```


# 9. Daily Hedging in Practice

Immunization isn't a one-time exercise. Rates move every day, and the hedge must be
**re-evaluated and adjusted** continuously. Here's what that looks like in practice.

## Day 1 — Measure Gaps at Current Rates

```{python}
# | label: daily-hedge-day1
rate_day1 = DISCOUNT_RATE  # 4.00%

# Portfolio PV
pv_assets_d1 = sum(a.present_value(rate_day1) for a in assets)
pv_liab_d1 = (
    wl.present_value(rate_day1)
    + spia.present_value(rate_day1)
    + fia.present_value(fia_index_rates, rate_day1)
)

# Duration and convexity gaps
dv01_a_d1 = sum(dv01(a.present_value, rate_day1) for a in assets)
dv01_l_d1 = (
    dv01(wl.present_value, rate_day1)
    + dv01(spia.present_value, rate_day1)
    + dv01(fia_pv_func, rate_day1)
)
dc_a_d1 = sum(dollar_convexity(a.present_value, rate_day1) for a in assets)
dc_l_d1 = (
    dollar_convexity(wl.present_value, rate_day1)
    + dollar_convexity(spia.present_value, rate_day1)
    + dollar_convexity(fia_pv_func, rate_day1)
)

day1_summary = pl.DataFrame({
    "side": ["Assets", "Liabilities", "Gap (L − A)"],
    "present_value": [pv_assets_d1, pv_liab_d1, pv_assets_d1 - pv_liab_d1],
    "dv01": [dv01_a_d1, dv01_l_d1, dv01_l_d1 - dv01_a_d1],
    "dollar_convexity": [dc_a_d1, dc_l_d1, dc_l_d1 - dc_a_d1],
})
styled_gt(day1_summary, f"Day 1 Portfolio — Rate: {rate_day1:.2%}").fmt_currency(
    ["present_value", "dv01", "dollar_convexity"], decimals=0
)
```

## Size the Hedge — Two Swaps

```{python}
# | label: daily-hedge-size
# Use 5Y and 20Y swaps for good duration/convexity separation
unit_5y = InterestRateSwap(notional=1, fixed_rate=rate_day1, tenor=5, pay_fixed=False)
unit_20y = InterestRateSwap(notional=1, fixed_rate=rate_day1, tenor=20, pay_fixed=False)

def swap_pv_5y(r: float) -> float:
    return unit_5y.present_value([r] * unit_5y.n_periods, r)

def swap_pv_20y(r: float) -> float:
    return unit_20y.present_value([r] * unit_20y.n_periods, r)

dd_gap_d1 = dv01_l_d1 - dv01_a_d1
dc_gap_d1 = dc_l_d1 - dc_a_d1

n_5y, n_20y = immunize(
    dd_gap=dd_gap_d1, dc_gap=dc_gap_d1,
    dd_per_unit_1=dv01(swap_pv_5y, rate_day1),
    dc_per_unit_1=dollar_convexity(swap_pv_5y, rate_day1),
    dd_per_unit_2=dv01(swap_pv_20y, rate_day1),
    dc_per_unit_2=dollar_convexity(swap_pv_20y, rate_day1),
)

# Round to nearest $100k
n_5y = round(n_5y / 100_000) * 100_000
n_20y = round(n_20y / 100_000) * 100_000

hedge_sizing = pl.DataFrame({
    "instrument": ["5Y Swap", "20Y Swap"],
    "notional": [n_5y, n_20y],
    "direction": [
        "Pay-fixed" if n_5y < 0 else "Receive-fixed",
        "Pay-fixed" if n_20y < 0 else "Receive-fixed",
    ],
})
styled_gt(hedge_sizing, "Hedge Trade — Day 1").fmt_currency("notional", decimals=0)
```

## Day 2 — Rates Drop 50bps Overnight

```{python}
# | label: daily-hedge-day2
rate_day2 = 0.035  # 3.50%

# Sized swaps
swap_hedge_5y = InterestRateSwap(
    notional=abs(n_5y), fixed_rate=rate_day1, tenor=5, pay_fixed=(n_5y < 0),
)
swap_hedge_20y = InterestRateSwap(
    notional=abs(n_20y), fixed_rate=rate_day1, tenor=20, pay_fixed=(n_20y < 0),
)

# Day 1 values
pv_hedge_d1 = (
    swap_hedge_5y.present_value([rate_day1] * swap_hedge_5y.n_periods, rate_day1)
    + swap_hedge_20y.present_value([rate_day1] * swap_hedge_20y.n_periods, rate_day1)
)
surplus_unhedged_d1 = pv_assets_d1 - pv_liab_d1
surplus_hedged_d1 = pv_assets_d1 + pv_hedge_d1 - pv_liab_d1

# Day 2 values
pv_assets_d2 = sum(a.present_value(rate_day2) for a in assets)
pv_liab_d2 = (
    wl.present_value(rate_day2)
    + spia.present_value(rate_day2)
    + fia.present_value(fia_index_rates, rate_day2)
)
pv_hedge_d2 = (
    swap_hedge_5y.present_value([rate_day2] * swap_hedge_5y.n_periods, rate_day2)
    + swap_hedge_20y.present_value([rate_day2] * swap_hedge_20y.n_periods, rate_day2)
)
surplus_unhedged_d2 = pv_assets_d2 - pv_liab_d2
surplus_hedged_d2 = pv_assets_d2 + pv_hedge_d2 - pv_liab_d2

impact_df = pl.DataFrame({
    "day": ["Day 1 (4.00%)", "Day 2 (3.50%)", "Change"],
    "assets": [pv_assets_d1, pv_assets_d2, pv_assets_d2 - pv_assets_d1],
    "liabilities": [pv_liab_d1, pv_liab_d2, pv_liab_d2 - pv_liab_d1],
    "hedge": [pv_hedge_d1, pv_hedge_d2, pv_hedge_d2 - pv_hedge_d1],
    "equity_unhedged": [surplus_unhedged_d1, surplus_unhedged_d2, surplus_unhedged_d2 - surplus_unhedged_d1],
    "equity_hedged": [surplus_hedged_d1, surplus_hedged_d2, surplus_hedged_d2 - surplus_hedged_d1],
})
styled_gt(impact_df, "Day 2 — Rate Impact (−50 bps)").fmt_currency(
    ["assets", "liabilities", "hedge", "equity_unhedged", "equity_hedged"], decimals=0
)
```

```{python}
# | label: daily-hedge-chart
surplus_compare = pl.DataFrame({
    "day": ["Day 1", "Day 2"],
    "unhedged": [surplus_unhedged_d1, surplus_unhedged_d2],
    "hedged": [surplus_hedged_d1, surplus_hedged_d2],
})
fig = plot.bar_chart(
    surplus_compare,
    x="day",
    y=["unhedged", "hedged"],
    title="Equity: Unhedged vs Hedged After −50bps Shock",
    xlab="",
    ylab="Equity",
    yformat="$",
    barmode="group",
)
fig.show()
```

::: {.callout-important}
## Daily Reality
Without the hedge, a single overnight rate move can wipe out millions in surplus.
With duration + convexity matching, surplus is stabilized — but the hedge must be
recalibrated every day as rates, durations, and portfolio composition change.
:::


# 10. Conclusion

::: {.callout-tip}
## Key Takeaways

- Assets must be structured to meet liabilities under multiple rate scenarios
- **Duration** and **convexity** are the primary tools for measuring interest rate risk
- **DV01** translates rate sensitivity into dollar terms at the portfolio level
- **Immunization** (matching duration + convexity) protects surplus from rate movements
- **Strategic Asset Allocation** and **interest rate swaps** are practical hedging tools
- Diversification across asset classes reduces mismatch risk
- Regular surplus monitoring is essential for actuarial compliance
:::

## Key ALM Strategies

| Strategy | Description |
|---|---|
| **Immunization** | Match duration and convexity of assets to liabilities to protect surplus |
| **Cash Flow Matching** | Structure asset cash flows to precisely meet liability payment schedules |
| **Surplus Optimization** | Maximize expected surplus return subject to risk constraints |

## Questions & Discussion

Source code: [github.com/realslimslaney/ALM](https://github.com/realslimslaney/ALM)
