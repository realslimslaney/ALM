---
title: "UA ALM 20260210"
format:
  html:
    toc: true
    number-sections: false
    colorlinks: true
    embed-resources: true
    html-math-method: webtex
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
    geometry:
      - left=0.5in
      - right=0.5in
      - top=0.5in
      - bottom=0.5in
    papersize: letter
    fontsize: 11pt
---

```{python}
# | label: setup
from datetime import date
import logging
import numpy as np
import polars as pl
import plotly.graph_objects as go
import plotly.io as pio
import os
from pathlib import Path
import sys

from great_tables import GT, style, loc

sys.path.insert(0, str((Path.cwd().parent) / "src"))
from alm.asset import Bond, PrivateCredit
from alm.liability import SPIA, Term, WL, FIA, qx_from_table
from alm.read import get_2012_iam_table, read_treasury_rates, update_credit_spreads
from alm.core import (
    Block,
    InterestRateSwap,
    SAA,
    default_saa,
    spia_saa,
    dv01,
    dollar_convexity,
    immunize,
    irr,
)
from alm import plot

logger = logging.getLogger(__name__)

pdf_bool = os.environ.get("QUARTO_PROJECT_OUTPUT_FORMAT") == "pdf"
if pdf_bool:
    pio.renderers.default = "png"
else:
    pio.renderers.default = "notebook_connected+vscode"

update_credit_spreads()

DISCOUNT_RATE = 0.04

BRAND = "#2563eb"  # blue from palette


def styled_gt(df, title=None):
    """GT table with branded header and styled column labels."""
    gt = GT(df)
    if title:
        gt = gt.tab_header(title)
    return gt.tab_options(
        heading_background_color=BRAND,
        column_labels_background_color="#dbeafe",
        column_labels_font_weight="bold",
    ).tab_style(
        style=style.text(color="white", weight="bold"),
        locations=loc.header(),
    )


today = date.today()
logger.info("DATE: %s", today)
logger.info("AUTHOR: Brennen Slaney, FSA")
logger.info("SOURCE: https://github.com/realslimslaney/ALM")
```

# 1. Introduction 
{{< include ../docs/brennen-slaney.md >}}


# 2. Building Blocks of ALM

## Insurance Company Balance Sheet
An insurance company's balance sheet is made up of three key components:

1. **Assets** — The investments the company holds (bonds, mortgages, private credit)

2. **Liabilities** — The obligations the company owes to policyholders (annuities, life insurance)

3. **Equity (Surplus)** — The residual value that belongs to shareholders after settling liabilities with assets

![Balance Sheet](../images/balance_sheet.png){width=80%}

## Assets

**Assets are the money you have.** Most of it is invested in safe, predictable instruments:

- Treasuries (government bonds — safe, liquid, benchmark yield)
- Highly rated corporate bonds
- Mortgage-Backed Securities
- Private credit (higher yield for illiquidity & credit risk)


The goal is **positive expected yield with lower variance**. Regulators enforce capital requirements and "score" the safety of assets. Investment teams manage the portfolio, but actuaries are often involved.

For this presentation we'll use the following sample portfolio:

```{python}
# | label: assets
from alm.read import read_treasury_rates

rates = read_treasury_rates()

assets = [
    Bond(face_value=8_000_000, coupon_rate=0.0390, maturity=2, frequency=2, rating="AAA"),
    Bond(
        face_value=10_000_000,
        coupon_rate=0.0425,
        maturity=5,
        frequency=2,
        rating="A",
        credit_spread=0.0027,
    ),
    PrivateCredit(
        face_value=5_000_000,
        maturity=7,
        risk_free_rate=0.04,
        credit_spread=0.03,
        illiquidity_spread=0.020,
        other_spread=0.005,
        rating="BB",
    ),
    Bond(face_value=15_000_000, coupon_rate=0.0400, maturity=10, frequency=2, rating="AAA"),
    Bond(face_value=8_000_000, coupon_rate=0.0420, maturity=20, frequency=2, rating="AA"),
]

# Private credit: low stated coupon, yield captured in purchase price discount
pc_display_coupon = 0.015
pc_purchase_price = Bond(
    face_value=assets[2].face_value,
    coupon_rate=pc_display_coupon,
    maturity=assets[2].maturity,
    frequency=assets[2].frequency,
).present_value(assets[2].total_yield)

asset_summary = pl.DataFrame(
    {
        "instrument": [
            "$8M UST 2Y",
            "$10M Corp A 5Y",
            "$5M PC BB 7Y",
            "$15M UST 10Y",
            "$8M AA 20Y",
        ],
        "face_value": [a.face_value for a in assets],
        "purchase_price": [
            assets[0].present_value(DISCOUNT_RATE),
            assets[1].present_value(DISCOUNT_RATE),
            pc_purchase_price,
            assets[3].present_value(DISCOUNT_RATE),
            assets[4].present_value(DISCOUNT_RATE),
        ],
        "coupon_rate": [
            assets[0].coupon_rate,
            assets[1].coupon_rate,
            pc_display_coupon,
            assets[3].coupon_rate,
            assets[4].coupon_rate,
        ],
        "irr": [
            assets[0].coupon_rate,
            assets[1].coupon_rate,
            assets[2].total_yield,
            assets[3].coupon_rate,
            assets[4].coupon_rate,
        ],
        "maturity": [2, 5, 7, 10, 20],
    }
)
styled_gt(asset_summary, "Sample Asset Portfolio").fmt_currency(
    ["face_value", "purchase_price"], decimals=0
).fmt_percent(["coupon_rate", "irr"], decimals=2).fmt_number("maturity", decimals=0)
```

```{python}
# | label: asset-portfolio-chart
fig = plot.bar_chart(
    asset_summary,
    x="instrument",
    y="face_value",
    title="Portfolio Composition by Face Value",
    xlab="Instrument",
    ylab="Face Value",
    yformat="$",
)
fig.show()
```

## Liabilities

**Liabilities are money you owe.** Nearly every insurance contract comes with a liability for the insurer. The timing and amount can be known or unknown:

- **Known** — Annuity Certain (fixed schedule of payments)
- **Unknown** — Term Life (death benefit contingent on mortality)

**Actuaries are the liability experts!**

```{python}
# | label: liabilities
mortality = get_2012_iam_table()

# Whole Life block: $10M face value, net level premium via equivalence principle
qx_wl = qx_from_table(mortality, age=45, sex="male")
wl = WL.from_face(face_value=10_000_000, qx=qx_wl, discount_rate=DISCOUNT_RATE, age=45)

# SPIA block: $3M annual payout, fair single premium = PV of expected payouts
qx_spia = qx_from_table(mortality, age=65, sex="female")
spia = SPIA.from_payout(annual_payout=3_000_000, qx=qx_spia, discount_rate=DISCOUNT_RATE, age=65)

liab_summary = pl.DataFrame(
    {
        "product": ["Whole Life", "SPIA"],
        "amount": [wl.face_value, spia.annual_payout],
        "amount_label": ["face value", "annual payout"],
        "premium": [wl.annual_premium, spia.premium],
        "premium_label": ["annual", "single"],
        "age": [wl.age, spia.age],
    }
)
styled_gt(liab_summary, "Liability Summary").fmt_currency(
    ["amount", "premium"], decimals=0
).fmt_number("age", decimals=0)
```

## Equity

**Equity = Assets - Liabilities**

- Without equity, a company will be liquidated by regulators
- Stability is important — you don't want drastic swings
- Excess capital funds expansion, retained earnings, and dividends
- When you buy a stock, you are taking a stake in their equity. $0 Equity = $0 Stock Price

::: {.callout-tip}
## Example
If Assets = $50M and Liabilities = $40M, then Equity = $10M.
That $10M funds new projects, dividends, bonuses, regulatory requirements.
:::


# 3. Cashflows from Assets and Liabilities

What do these things actually look like?

## Asset Cashflows

```{python}
# | label: asset-cashflows
# Show cashflows for the 2Y Treasury (4 semi-annual periods — a complete bond lifecycle)
ust_2y = assets[0]

styled_gt(
    ust_2y.cashflows(), "$8M UST 2Y — All Cashflows"
).fmt_currency(
    ["coupon", "principal", "total"], decimals=0
)
```

```{python}
# | label: asset-cashflow-metrics
logger.info("$8M UST 2Y: PV @ %s = $%s", f"{DISCOUNT_RATE:.0%}", f"{ust_2y.present_value(DISCOUNT_RATE):,.0f}")
logger.info("$8M UST 2Y: Duration = %.2f years", ust_2y.duration(DISCOUNT_RATE))
```

```{python}
# | label: asset-cashflow-charts
# Cashflow profiles for each asset — shows how maturity drives timing
instrument_names = asset_summary["instrument"].to_list()

fig = go.Figure()
for i, (asset, name) in enumerate(zip(assets, instrument_names)):
    cf = asset.cashflows()
    years = [t / asset.frequency for t in cf["period"].to_list()]
    totals = cf["total"].to_list()
    fig.add_trace(go.Scatter(
        x=years, y=totals, mode="lines", name=name,
        line=dict(color=plot.PALETTE[i % len(plot.PALETTE)]),
    ))

fig.update_layout(
    template="plotly_white",
    title="Asset Cashflow Profiles by Instrument",
    xaxis_title="Year", yaxis_title="Cashflow",
    yaxis_tickprefix="$", yaxis_tickformat=",.0f",
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    margin=dict(l=60, r=30, t=60, b=50),
    hovermode="x unified",
)
fig.show()
```

Each bond pays level coupons then returns full principal at maturity — the spike at the end.
Longer maturities push that principal repayment further out, increasing duration.
The private credit instrument has a lower stated coupon (purchased at a discount), so its
coupon line sits below the others relative to its face value.

## Liability Cashflows

```{python}
# | label: liability-cashflows
wl_cf = wl.cashflows()
# Find the peak expected_benefit month and grab 5 months around it
peak_idx = wl_cf["expected_benefit"].arg_max()
peak_start = max(0, peak_idx - 2)
peak_slice = wl_cf.slice(peak_start, 5)
wl_display = (
    pl.concat([wl_cf.head(5), peak_slice])
    .with_columns(pl.col("period").alias("month"))
    .select("month", "survival_prob", "expected_premium", "expected_benefit", "net_cashflow")
)
styled_gt(
    wl_display, "Whole Life — Monthly Cashflows (first 5 & peak liability months)"
).fmt_currency(["expected_premium", "expected_benefit", "net_cashflow"], decimals=0).fmt_number(
    "survival_prob", decimals=4
).fmt_number("month", decimals=0)
```

```{python}
# | label: liability-cashflows-spia
spia_cf = spia.cashflows()
spia_display = spia_cf.head(12).with_columns(
    pl.col("period").alias("month")
).select("month", "survival_prob", "payout", "expected_payout")
styled_gt(
    spia_display, "SPIA — Expected Monthly Cashflows (first 12 months)"
).fmt_currency(["payout", "expected_payout"], decimals=0).fmt_number(
    "survival_prob", decimals=4
).fmt_number("month", decimals=0)
```

::: {layout-ncol=2}

```{python}
# | label: liability-cashflow-chart-wl
# Aggregate WL to annual
wl_annual = wl_cf.group_by((pl.col("period") - 1) // wl.frequency).agg(
    pl.col("year").max().alias("year"),
    pl.col("net_cashflow").sum().alias("net_cashflow"),
)
fig = plot.line_chart(
    wl_annual.sort("year").head(40),
    x="year",
    y="net_cashflow",
    title="WL — Annual Net Cashflows",
    xlab="Year",
    ylab="Annual Cashflow",
    yformat="$",
)
fig.show()
```

```{python}
# | label: liability-cashflow-chart-spia
# Aggregate SPIA to annual
spia_annual = spia_cf.group_by((pl.col("period") - 1) // spia.frequency).agg(
    pl.col("year").max().alias("year"),
    pl.col("expected_payout").sum().alias("expected_payout"),
)
fig = plot.line_chart(
    spia_annual.sort("year").head(40),
    x="year",
    y="expected_payout",
    title="SPIA — Annual Expected Payouts",
    xlab="Year",
    ylab="Annual Payout",
    yformat="$",
)
fig.show()
```

:::

## Equity (Surplus) View

```{python}
# | label: equity-view
total_asset_pv = sum(a.present_value(DISCOUNT_RATE) for a in assets)
wl_pv = wl.present_value(DISCOUNT_RATE)
spia_pv = spia.present_value(DISCOUNT_RATE)
total_liab_pv = wl_pv + spia_pv

equity_df = pl.DataFrame({
    "component": ["Assets", "Liabilities", "Surplus (Equity)"],
    "present_value": [total_asset_pv, total_liab_pv, total_asset_pv - total_liab_pv],
})
styled_gt(equity_df, "Balance Sheet — Present Values").fmt_currency("present_value", decimals=0)
```

```{python}
# | label: balance-sheet-chart
fig = plot.bar_chart(
    equity_df,
    x="component",
    y="present_value",
    title="Balance Sheet at 4% Discount Rate",
    xlab="",
    ylab="Present Value",
    yformat="$",
)
fig.show()
```




# 4. Key Mathematical Concepts

How do actuaries measure the financial risk of interest rates?

## Duration

**Duration** is the time-weighted average of the present value of cashflows.
It measures a bond's sensitivity to interest rate changes and helps us
linearly estimate price changes from rate movements.

$$
D = \frac{1}{P} \sum_{t=1}^{n} \frac{t}{f} \cdot \frac{CF_t}{(1 + y/f)^t}
$$

```{python}
# | label: duration-example
bond_example = Bond(face_value=100, coupon_rate=0.02, maturity=30, frequency=2)
base_rate = 0.02
dur = bond_example.duration(base_rate)
logger.info("30Y 2%% semi-annual bond: Duration = %.2f years", dur)
```

## Convexity

**Convexity** captures the second-order (curvature) effect of yield changes on price.
Using duration *and* convexity leads to better price-change estimates.

$$
C = \frac{1}{P \cdot f^2} \sum_{t=1}^{n} \frac{t(t+1) \cdot CF_t}{(1 + y/f)^{t+2}}
$$

The second-order price approximation is:

$$
\frac{\Delta P}{P} \approx -D_{\text{mod}} \cdot \Delta y + \tfrac{1}{2} \cdot C \cdot (\Delta y)^2
$$

```{python}
# | label: convexity-example
conv = bond_example.convexity(base_rate)
mod_dur = dur / (1 + base_rate / 2)

logger.info("Modified Duration: %.2f", mod_dur)
logger.info("Convexity:         %.2f", conv)

# Price change estimates across a continuous range of shocks
shock_range = [s / 1000 for s in range(-30, 31)]
approx_rows = []
pv_base = bond_example.present_value(base_rate)
for s in shock_range:
    actual = (bond_example.present_value(base_rate + s) - pv_base) / pv_base
    dur_only = -mod_dur * s
    dur_conv = -mod_dur * s + 0.5 * conv * s**2
    approx_rows.append({
        "rate_shock": s,
        "actual": actual,
        "duration_only": dur_only,
        "duration_convexity": dur_conv,
    })

approx_df = pl.DataFrame(approx_rows)
```

::: {layout-ncol=2}

```{python}
# | label: duration-approx-chart
fig = go.Figure()
fig.add_trace(go.Scatter(
    x=approx_df["rate_shock"].to_list(), y=approx_df["actual"].to_list(),
    mode="lines", name="actual", line=dict(color="#2563eb"),
))
fig.add_trace(go.Scatter(
    x=approx_df["rate_shock"].to_list(), y=approx_df["duration_only"].to_list(),
    mode="lines", name="duration estimate", line=dict(color="#dc2626", dash="dash"),
))
fig.update_layout(
    template="plotly_white", title="Actual vs Duration Estimate",
    xaxis_title="Rate Shock", yaxis_title="% Price Change",
    xaxis_tickformat=".1%", yaxis_tickformat=".0%",
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    margin=dict(l=60, r=30, t=60, b=50),
)
fig.show()
```

```{python}
# | label: convexity-approx-chart
fig = go.Figure()
fig.add_trace(go.Scatter(
    x=approx_df["rate_shock"].to_list(), y=approx_df["actual"].to_list(),
    mode="lines", name="actual", line=dict(color="#2563eb"),
))
fig.add_trace(go.Scatter(
    x=approx_df["rate_shock"].to_list(), y=approx_df["duration_convexity"].to_list(),
    mode="lines", name="duration + convexity", line=dict(color="#16a34a", dash="dash"),
))
fig.update_layout(
    template="plotly_white", title="Actual vs Duration + Convexity",
    xaxis_title="Rate Shock", yaxis_title="% Price Change",
    xaxis_tickformat=".1%", yaxis_tickformat=".0%",
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    margin=dict(l=60, r=30, t=60, b=50),
)
fig.show()
```

:::

## DV01 (Dollar Value of a Basis Point)

The dollar change in value for a 1 bps parallel shift in the yield curve.
This tells us how much money we expect our portfolio to move from a 1 bps shift.

$$
\text{DV01} = \frac{PV(y - 0.0001) - PV(y + 0.0001)}{2}
$$

```{python}
# | label: dv01-example
dv01_df = pl.DataFrame(
    {
        "instrument": asset_summary["instrument"].to_list(),
        "dv01": [dv01(a.present_value, DISCOUNT_RATE) for a in assets],
    }
)
styled_gt(dv01_df, "DV01 by Instrument").fmt_currency("dv01", decimals=0)
```

```{python}
# | label: dv01-chart
fig = plot.bar_chart(
    dv01_df,
    x="instrument",
    y="dv01",
    title="DV01 by Instrument",
    xlab="",
    ylab="DV01",
    yformat="$",
)
fig.show()
```

## Key Rate Duration (KRD)

The dollar change in value for a 1 bps shift at a **specific duration** on the yield curve. For example, KRD-7 measures the Dollar-Duration impact of a rate shift ONLY at year 7.

Key properties:

- KRDs across all tenors sum to the bond's effective duration
- A bullet bond has KRD concentrated at its maturity
- An amortizing bond (e.g. mortgage) has KRD spread across many tenors

```{python}
# | label: krd-visual
# Visualise KRD: PV of each cashflow at baseline vs with a rate shock from year 5+
ust_10y = assets[3]
cf_10y = ust_10y.cashflows()
r_base = DISCOUNT_RATE / ust_10y.frequency
bump = 0.01  # +100 bps forward shock at year 5

years_krd = [t / ust_10y.frequency for t in cf_10y["period"].to_list()]
pv_baseline = []
pv_shocked = []

for t, total in zip(cf_10y["period"].to_list(), cf_10y["total"].to_list()):
    yr = t / ust_10y.frequency
    pv_baseline.append(total / (1 + r_base) ** t)
    # Shock: rates +100bps for cashflows at year 5 and beyond
    if yr >= 5:
        r_bump = (DISCOUNT_RATE + bump) / ust_10y.frequency
        pv_shocked.append(total / (1 + r_bump) ** t)
    else:
        pv_shocked.append(total / (1 + r_base) ** t)

krd_df = pl.DataFrame({"year": years_krd, "baseline (4%)": pv_baseline, "shocked (5% from yr 5)": pv_shocked})

fig = go.Figure()
fig.add_trace(go.Scatter(
    x=years_krd, y=pv_baseline, mode="lines+markers", name="Baseline (4%)",
    line=dict(color="#2563eb"), marker=dict(size=5),
))
fig.add_trace(go.Scatter(
    x=years_krd, y=pv_shocked, mode="lines+markers", name="Shocked (+100bps from Year 5)",
    line=dict(color="#dc2626", dash="dash"), marker=dict(size=5),
))
fig.add_vrect(x0=5, x1=10.5, fillcolor="#dc2626", opacity=0.05, line_width=0,
              annotation_text="Shocked region", annotation_position="top left")
fig.update_layout(
    template="plotly_white",
    title="$15M UST 10Y — PV of Cashflows: Baseline vs Key Rate Shock",
    xaxis_title="Year", yaxis_title="PV of Cashflow",
    yaxis_tickprefix="$", yaxis_tickformat=",.0f",
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    margin=dict(l=60, r=30, t=60, b=50),
)
fig.show()
```

The gap between the two lines from year 5 onward shows where **Key Rate Duration** sensitivity lives.
Long-dated cashflows (especially the principal at maturity) are most affected by rate shocks at their tenor.

## Immunization (Preview)

::: {.callout-important}
## Redington Immunization Conditions
Immunization protects a portfolio's ability to meet liabilities against interest rate movements:

1. **PV Match:** PV(Assets) = PV(Liabilities)
2. **Duration Match:** Duration(Assets) = Duration(Liabilities)
3. **Convexity Condition:** Convexity(Assets) >= Convexity(Liabilities)
:::


# 5. Revisit Cashflows with Rate Shocks

What happens when interest rates move?

```{python}
# | label: rate-shocks
shocks = [-0.01, 0.0, 0.01, 0.02]

rows = []
for shock in shocks:
    r = DISCOUNT_RATE + shock
    pv_a = sum(a.present_value(r) for a in assets)
    pv_l = wl.present_value(r) + spia.present_value(r)
    rows.append({
        "rate_shock": f"{shock:+.0%}",
        "discount_rate": f"{r:.1%}",
        "pv_assets": pv_a,
        "pv_liabilities": pv_l,
        "surplus": pv_a - pv_l,
    })

shock_df = pl.DataFrame(rows)
styled_gt(shock_df, "Present Values Under Rate Shocks").fmt_currency(["pv_assets", "pv_liabilities", "surplus"], decimals=0)
```

```{python}
# | label: rate-shock-chart
fig = plot.bar_chart(
    shock_df,
    x="rate_shock",
    y=["pv_assets", "pv_liabilities"],
    title="PV of Assets vs Liabilities Under Rate Shocks",
    xlab="Rate Shock",
    ylab="Present Value",
    yformat="$",
    barmode="group",
)
fig.show()
```

```{python}
# | label: pv-sensitivity-curves
# Continuous PV sensitivity across a wider rate range
rate_range = [r / 1000 for r in range(10, 81)]
pv_curve_rows = []
for r in rate_range:
    pv_a = sum(a.present_value(r) for a in assets)
    pv_l = wl.present_value(r) + spia.present_value(r)
    pv_curve_rows.append({"discount_rate": r, "pv_assets": pv_a, "pv_liabilities": pv_l})

pv_curve_df = pl.DataFrame(pv_curve_rows)
fig = plot.line_chart(
    pv_curve_df,
    x="discount_rate",
    y=["pv_assets", "pv_liabilities"],
    title="PV Sensitivity to Interest Rates",
    xlab="Discount Rate",
    ylab="Present Value",
    yformat="$",
    xformat="%",
)
fig.show()
```

::: {.callout-warning}
## Key Observation
Notice how assets and liabilities respond **differently** to rate changes.
This mismatch is the core problem ALM solves.
:::


# 6. Strategic Asset Allocation by Block

Different liability types have different duration profiles.
A smart insurer matches its **asset allocation** to the duration of the liabilities it backs.

## Two Blocks of Business

We build two blocks:

- **Short-duration** (Term Life, ages 30–50): ~20-year policies, payouts concentrated in early years
- **Long-duration** (SPIA, ages 60–75): lifetime payouts, cashflows stretch 30+ years

```{python}
# | label: block-saa-setup
short_saa = SAA(weights={
    "govt_bonds": 0.55,
    "corp_bonds": 0.25,
    "mortgages": 0.15,
    "private_credit": 0.05,
})

long_saa = SAA(weights={
    "govt_bonds": 0.25,
    "corp_bonds": 0.45,
    "mortgages": 0.20,
    "private_credit": 0.10,
})

saa_compare = pl.DataFrame({
    "asset_class": list(short_saa.weights.keys()),
    "short_duration_block": list(short_saa.weights.values()),
    "long_duration_block": list(long_saa.weights.values()),
})
styled_gt(saa_compare, "SAA by Liability Duration").fmt_percent(
    ["short_duration_block", "long_duration_block"], decimals=0
)
```

**Why the difference?**

- Short-duration liabilities need **liquidity** and **safety** → more government bonds
- Long-duration liabilities can tolerate **longer tenor** and **credit risk** → more corporate bonds
- The spread earned on longer-dated corporate bonds compensates for additional credit and duration risk

```{python}
# | label: block-generation
short_block = Block(
    liability_type="Term",
    saa=short_saa,
    total_liability_amount=20_000_000,
    mortality_table=mortality,
    age_range=(30, 50),
    discount_rate=DISCOUNT_RATE,
    n_policies=200,
    seed=42,
)
_ = short_block.generate_policies()
_ = short_block.generate_assets()

long_block = Block(
    liability_type="SPIA",
    saa=long_saa,
    total_liability_amount=20_000_000,
    mortality_table=mortality,
    age_range=(60, 75),
    discount_rate=DISCOUNT_RATE,
    n_policies=200,
    seed=42,
)
_ = long_block.generate_policies()
_ = long_block.generate_assets()
```

## Cashflow Comparison

*Note: These cashflows assume no reinvestment of asset proceeds as a simplifying assumption. In practice, maturing bonds and coupon income would be reinvested, smoothing asset cashflows over time. This leads to higher asset cashflows in earlier time periods than a fully built model would show.*

```{python}
# | label: block-short-cf
fig_short = short_block.plot_cashflows()
fig_short.show()
```

```{python}
# | label: block-long-cf
fig_long = long_block.plot_cashflows()
fig_long.show()
```

## IRR Comparison

The **Internal Rate of Return (IRR)** on the asset side tells us the expected yield
the insurer earns on each block. Longer blocks with more private credit should
earn a higher return — the reward for accepting illiquidity.

```{python}
# | label: block-irr
short_asset_cf = short_block.asset_cashflows()
long_asset_cf = long_block.asset_cashflows()

# Build IRR cashflows: initial premium outflow + asset inflows by year
short_irr_cfs = [-short_block.premium] + short_asset_cf["cashflow"].to_list()
long_irr_cfs = [-long_block.premium] + long_asset_cf["cashflow"].to_list()

short_irr = irr(short_irr_cfs)
long_irr = irr(long_irr_cfs)

irr_df = pl.DataFrame({
    "block": ["Short-Duration (Term)", "Long-Duration (SPIA)"],
    "saa_pc_weight": [short_saa.weights["private_credit"], long_saa.weights["private_credit"]],
    "irr": [short_irr, long_irr],
})
styled_gt(irr_df, "Asset IRR by Block").fmt_percent(
    ["saa_pc_weight", "irr"], decimals=2
)
```

::: {.callout-tip}
## Key Insight
The long-duration block earns a higher IRR because it allocates more to corporate bonds
and private credit. The credit spread and illiquidity premium are real sources of return — but only
appropriate when the liabilities are long enough to wait.
:::


# 7. Duration Hedging with Swaps

## Strategic Asset Allocation

**Strategic Asset Allocation (SAA)** determines how well assets and liabilities naturally hedge each other.

- Are our liabilities and assets of similar duration and convexity?
- Are they similarly sensitive to interest rates?
- If our bonds change in value similarly to our annuities, we have a natural ALM hedge
- If they respond differently, we need to **actively stabilize** the surplus

```{python}
# | label: saa-example
saa = default_saa()
saa_df = pl.DataFrame({
    "asset_class": list(saa.weights.keys()),
    "weight": list(saa.weights.values()),
})
styled_gt(saa_df, "Default SAA Weights").fmt_percent("weight", decimals=0)
```

## Interest Rate Swaps

A plain-vanilla **interest rate swap** exchanges fixed payments for floating payments.
Swaps adjust portfolio duration without buying or selling bonds:

- **Receive-fixed** adds duration (like buying a bond)
- **Pay-fixed** removes duration (like selling a bond)

::: {.callout-note}
## Why Do Swaps Change Duration?

Think of an interest rate swap as two bonds packaged together:

| Position | Fixed Leg | Floating Leg | Net Duration |
|---|---|---|---|
| **Receive-fixed** | Long a fixed-rate bond (high duration) | Short a floating-rate note (≈ 0 duration) | **Positive** — adds duration |
| **Pay-fixed** | Short a fixed-rate bond (high duration) | Long a floating-rate note (≈ 0 duration) | **Negative** — removes duration |

A **floating-rate note** resets its coupon at each payment date, so its price barely moves when rates change (duration ≈ 0). A **fixed-rate bond** has locked-in coupons, so its price is highly sensitive to rates (duration > 0).

When you **receive fixed**, you are economically long the fixed-rate bond — so you inherit its duration. When you **pay fixed**, you are economically short the fixed-rate bond — so you remove that duration from your portfolio.
:::

```{python}
# | label: swap-example
swap_5y = InterestRateSwap(notional=10_000_000, fixed_rate=0.04, tenor=5, pay_fixed=False)
swap_10y = InterestRateSwap(notional=10_000_000, fixed_rate=0.04, tenor=10, pay_fixed=False)

flat_floats_5 = [0.04] * swap_5y.n_periods
flat_floats_10 = [0.04] * swap_10y.n_periods

swap_df = pl.DataFrame({
    "swap": ["5Y Receive-Fixed", "10Y Receive-Fixed"],
    "notional": [swap_5y.notional, swap_10y.notional],
    "dv01": [
        swap_5y.dv01(flat_floats_5, DISCOUNT_RATE),
        swap_10y.dv01(flat_floats_10, DISCOUNT_RATE),
    ],
})
styled_gt(swap_df, "Swap DV01").fmt_currency(["notional", "dv01"], decimals=0)
```

## Duration Gap Analysis

```{python}
# | label: duration-gap
asset_dv01 = sum(dv01(a.present_value, DISCOUNT_RATE) for a in assets)
liab_dv01 = dv01(wl.present_value, DISCOUNT_RATE) + dv01(spia.present_value, DISCOUNT_RATE)

gap_df = pl.DataFrame({
    "component": ["Assets", "Liabilities", "Gap (L - A)"],
    "dv01": [asset_dv01, liab_dv01, liab_dv01 - asset_dv01],
})
styled_gt(gap_df, "Duration Gap Analysis").fmt_currency("dv01", decimals=0)
```


# 8. Immunization

Immunization matches **both** duration and convexity to protect surplus against rate movements.

We solve a 2x2 system using two hedging instruments (e.g. a 5Y and 10Y swap):

$$
\begin{bmatrix}
\text{DV01}_1 & \text{DV01}_2 \\
DC_1 & DC_2
\end{bmatrix}
\begin{bmatrix}
n_1 \\ n_2
\end{bmatrix}
=
\begin{bmatrix}
\Delta\text{DV01} \\
\Delta DC
\end{bmatrix}
$$

where $DC$ denotes dollar convexity.

```{python}
# | label: immunization
asset_dc = sum(dollar_convexity(a.present_value, DISCOUNT_RATE) for a in assets)
liab_dc = dollar_convexity(wl.present_value, DISCOUNT_RATE) + dollar_convexity(spia.present_value, DISCOUNT_RATE)

dd_gap = liab_dv01 - asset_dv01
dc_gap = liab_dc - asset_dc

imm_gap_df = pl.DataFrame({
    "metric": ["Dollar Duration (DV01)", "Dollar Convexity"],
    "gap": [dd_gap, dc_gap],
})
styled_gt(imm_gap_df, "Gaps to Close").fmt_currency("gap", decimals=0)
```

```{python}
# | label: immunization-solve
# Per-unit sensitivities — bump floating rates with discount rate (parallel shift)
dd_5y = swap_5y.dv01(flat_floats_5, DISCOUNT_RATE) / swap_5y.notional
dc_5y = dollar_convexity(
    lambda r: swap_5y.present_value([r] * swap_5y.n_periods, r), DISCOUNT_RATE
) / swap_5y.notional
dd_10y = swap_10y.dv01(flat_floats_10, DISCOUNT_RATE) / swap_10y.notional
dc_10y = dollar_convexity(
    lambda r: swap_10y.present_value([r] * swap_10y.n_periods, r), DISCOUNT_RATE
) / swap_10y.notional

n1, n2 = immunize(dd_gap, dc_gap, dd_5y, dc_5y, dd_10y, dc_10y)

hedge_df = pl.DataFrame({
    "instrument": ["5Y Swap", "10Y Swap"],
    "notional": [n1, n2],
    "direction": ["Pay-fixed" if n1 < 0 else "Receive-fixed", "Pay-fixed" if n2 < 0 else "Receive-fixed"],
})
styled_gt(hedge_df, "Immunization Hedge Notionals").fmt_currency("notional", decimals=0)
```

```{python}
# | label: immunization-verify
# Verify: re-run rate shocks with the hedge in place
hedge_5y = InterestRateSwap(notional=abs(n1), fixed_rate=0.04, tenor=5, pay_fixed=(n1 < 0))
hedge_10y = InterestRateSwap(notional=abs(n2), fixed_rate=0.04, tenor=10, pay_fixed=(n2 < 0))

rows_hedged = []
for shock in shocks:
    r = DISCOUNT_RATE + shock
    pv_a = sum(a.present_value(r) for a in assets)
    floats_5 = [0.04 + shock] * hedge_5y.n_periods
    floats_10 = [0.04 + shock] * hedge_10y.n_periods
    pv_a += hedge_5y.present_value(floats_5, r)
    pv_a += hedge_10y.present_value(floats_10, r)
    pv_l = wl.present_value(r) + spia.present_value(r)
    rows_hedged.append({
        "rate_shock": f"{shock:+.0%}",
        "surplus_unhedged": rows[shocks.index(shock)]["surplus"],
        "surplus_hedged": pv_a - pv_l,
    })

hedged_df = pl.DataFrame(rows_hedged)
styled_gt(hedged_df, "Surplus: Unhedged vs Immunized").fmt_currency(["surplus_unhedged", "surplus_hedged"], decimals=0)
```

```{python}
# | label: immunization-chart
fig = plot.bar_chart(
    hedged_df,
    x="rate_shock",
    y=["surplus_unhedged", "surplus_hedged"],
    title="Surplus Stability: Unhedged vs Immunized",
    xlab="Rate Shock",
    ylab="Surplus",
    yformat="$",
    barmode="group",
)
fig.show()
```


# 9. Daily Hedging in Practice

Immunization isn't a one-time exercise. Rates move every day, and the hedge must be
**re-evaluated and adjusted** continuously. Here's what that looks like in practice.

## Day 1 — Measure Gaps at Current Rates

```{python}
# | label: daily-hedge-day1
rate_day1 = DISCOUNT_RATE  # 4.00%

# Portfolio PV
pv_assets_d1 = sum(a.present_value(rate_day1) for a in assets)
pv_liab_d1 = wl.present_value(rate_day1) + spia.present_value(rate_day1)

# Duration and convexity gaps
dv01_a_d1 = sum(dv01(a.present_value, rate_day1) for a in assets)
dv01_l_d1 = dv01(wl.present_value, rate_day1) + dv01(spia.present_value, rate_day1)
dc_a_d1 = sum(dollar_convexity(a.present_value, rate_day1) for a in assets)
dc_l_d1 = dollar_convexity(wl.present_value, rate_day1) + dollar_convexity(spia.present_value, rate_day1)

day1_summary = pl.DataFrame({
    "side": ["Assets", "Liabilities", "Gap (L − A)"],
    "present_value": [pv_assets_d1, pv_liab_d1, pv_assets_d1 - pv_liab_d1],
    "dv01": [dv01_a_d1, dv01_l_d1, dv01_l_d1 - dv01_a_d1],
    "dollar_convexity": [dc_a_d1, dc_l_d1, dc_l_d1 - dc_a_d1],
})
styled_gt(day1_summary, f"Day 1 Portfolio — Rate: {rate_day1:.2%}").fmt_currency(
    ["present_value", "dv01", "dollar_convexity"], decimals=0
)
```

## Size the Hedge — Two Swaps

```{python}
# | label: daily-hedge-size
# Use 5Y and 20Y swaps for good duration/convexity separation
unit_5y = InterestRateSwap(notional=1, fixed_rate=rate_day1, tenor=5, pay_fixed=False)
unit_20y = InterestRateSwap(notional=1, fixed_rate=rate_day1, tenor=20, pay_fixed=False)

def swap_pv_5y(r: float) -> float:
    return unit_5y.present_value([r] * unit_5y.n_periods, r)

def swap_pv_20y(r: float) -> float:
    return unit_20y.present_value([r] * unit_20y.n_periods, r)

dd_gap_d1 = dv01_l_d1 - dv01_a_d1
dc_gap_d1 = dc_l_d1 - dc_a_d1

n_5y, n_20y = immunize(
    dd_gap=dd_gap_d1, dc_gap=dc_gap_d1,
    dd_per_unit_1=dv01(swap_pv_5y, rate_day1),
    dc_per_unit_1=dollar_convexity(swap_pv_5y, rate_day1),
    dd_per_unit_2=dv01(swap_pv_20y, rate_day1),
    dc_per_unit_2=dollar_convexity(swap_pv_20y, rate_day1),
)

# Round to nearest $100k
n_5y = round(n_5y / 100_000) * 100_000
n_20y = round(n_20y / 100_000) * 100_000

hedge_sizing = pl.DataFrame({
    "instrument": ["5Y Swap", "20Y Swap"],
    "notional": [n_5y, n_20y],
    "direction": [
        "Pay-fixed" if n_5y < 0 else "Receive-fixed",
        "Pay-fixed" if n_20y < 0 else "Receive-fixed",
    ],
})
styled_gt(hedge_sizing, "Hedge Trade — Day 1").fmt_currency("notional", decimals=0)
```

## Day 2 — Rates Drop 50bps Overnight

```{python}
# | label: daily-hedge-day2
rate_day2 = 0.035  # 3.50%

# Sized swaps
swap_hedge_5y = InterestRateSwap(
    notional=abs(n_5y), fixed_rate=rate_day1, tenor=5, pay_fixed=(n_5y < 0),
)
swap_hedge_20y = InterestRateSwap(
    notional=abs(n_20y), fixed_rate=rate_day1, tenor=20, pay_fixed=(n_20y < 0),
)

# Day 1 values
pv_hedge_d1 = (
    swap_hedge_5y.present_value([rate_day1] * swap_hedge_5y.n_periods, rate_day1)
    + swap_hedge_20y.present_value([rate_day1] * swap_hedge_20y.n_periods, rate_day1)
)
surplus_unhedged_d1 = pv_assets_d1 - pv_liab_d1
surplus_hedged_d1 = pv_assets_d1 + pv_hedge_d1 - pv_liab_d1

# Day 2 values
pv_assets_d2 = sum(a.present_value(rate_day2) for a in assets)
pv_liab_d2 = wl.present_value(rate_day2) + spia.present_value(rate_day2)
pv_hedge_d2 = (
    swap_hedge_5y.present_value([rate_day2] * swap_hedge_5y.n_periods, rate_day2)
    + swap_hedge_20y.present_value([rate_day2] * swap_hedge_20y.n_periods, rate_day2)
)
surplus_unhedged_d2 = pv_assets_d2 - pv_liab_d2
surplus_hedged_d2 = pv_assets_d2 + pv_hedge_d2 - pv_liab_d2

impact_df = pl.DataFrame({
    "day": ["Day 1 (4.00%)", "Day 2 (3.50%)", "Change"],
    "assets": [pv_assets_d1, pv_assets_d2, pv_assets_d2 - pv_assets_d1],
    "liabilities": [pv_liab_d1, pv_liab_d2, pv_liab_d2 - pv_liab_d1],
    "hedge": [pv_hedge_d1, pv_hedge_d2, pv_hedge_d2 - pv_hedge_d1],
    "surplus_unhedged": [surplus_unhedged_d1, surplus_unhedged_d2, surplus_unhedged_d2 - surplus_unhedged_d1],
    "surplus_hedged": [surplus_hedged_d1, surplus_hedged_d2, surplus_hedged_d2 - surplus_hedged_d1],
})
styled_gt(impact_df, "Day 2 — Rate Impact (−50 bps)").fmt_currency(
    ["assets", "liabilities", "hedge", "surplus_unhedged", "surplus_hedged"], decimals=0
)
```

```{python}
# | label: daily-hedge-chart
surplus_compare = pl.DataFrame({
    "day": ["Day 1", "Day 2"],
    "unhedged": [surplus_unhedged_d1, surplus_unhedged_d2],
    "hedged": [surplus_hedged_d1, surplus_hedged_d2],
})
fig = plot.bar_chart(
    surplus_compare,
    x="day",
    y=["unhedged", "hedged"],
    title="Surplus: Unhedged vs Hedged After −50bps Shock",
    xlab="",
    ylab="Surplus",
    yformat="$",
    barmode="group",
)
fig.show()
```

::: {.callout-important}
## Daily Reality
Without the hedge, a single overnight rate move can wipe out millions in surplus.
With duration + convexity matching, surplus is stabilized — but the hedge must be
recalibrated every day as rates, durations, and portfolio composition change.
:::


# 10. Conclusion

::: {.callout-tip}
## Key Takeaways

- Assets must be structured to meet liabilities under multiple rate scenarios
- **Duration** and **convexity** are the primary tools for measuring interest rate risk
- **DV01** translates rate sensitivity into dollar terms at the portfolio level
- **Immunization** (matching duration + convexity) protects surplus from rate movements
- **Strategic Asset Allocation** and **interest rate swaps** are practical hedging tools
- Diversification across asset classes reduces mismatch risk
- Regular surplus monitoring is essential for actuarial compliance
:::

## Key ALM Strategies

| Strategy | Description |
|---|---|
| **Immunization** | Match duration and convexity of assets to liabilities to protect surplus |
| **Cash Flow Matching** | Structure asset cash flows to precisely meet liability payment schedules |
| **Surplus Optimization** | Maximize expected surplus return subject to risk constraints |

## Questions & Discussion

Source code: [github.com/realslimslaney/ALM](https://github.com/realslimslaney/ALM)
