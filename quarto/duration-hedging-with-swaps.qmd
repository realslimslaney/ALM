---
title: "Duration Hedging with Interest Rate Swaps"
format:
  html:
    toc: true
    code-fold: false
    self-contained: true
execute:
  echo: true
  warning: false
---

This tutorial walks through a simple ALM example: an insurer holds a
small portfolio of bonds backing two insurance liabilities, and uses an
interest rate swap to close a duration gap when rates change overnight.

```{python}
import sys
from pathlib import Path

# make the alm package importable when running from docs/tutorial/
sys.path.insert(0, str(Path.cwd().parents[1] / "src"))

import polars as pl
from great_tables import GT

from alm.asset import Bond
from alm.liability import SPIA, Term
from alm.core import InterestRateSwap
```

## Step 1 — Build the portfolio

### Assets

The insurer holds two bonds:

| Bond | Face | Coupon | Maturity | Frequency |
|------|------|--------|----------|-----------|
| A    | $5M  | 3.5 %  | 5 yr     | Semi-ann  |
| B    | $3M  | 4.5 %  | 10 yr    | Semi-ann  |

```{python}
bond_a = Bond(face_value=5_000_000, coupon_rate=0.035, maturity=5, frequency=2)
bond_b = Bond(face_value=3_000_000, coupon_rate=0.045, maturity=10, frequency=2)
```

### Liabilities

The insurer has written two policies:

* A **SPIA** paying \$300 000 / year for up to 30 years (monthly, life only).
* A **20-year Term Life** policy with a \$1 000 000 face value and
  \$5 000 annual premium.

We use a flat 1 % annual mortality rate for simplicity.

```{python}
qx = [0.01] * 30

spia = SPIA(
    premium=4_000_000,
    annual_payout=300_000,
    qx=qx,
    frequency=12,
    certain_period=0,
)

term = Term(
    face_value=1_000_000,
    annual_premium=5_000,
    term=20,
    qx=qx,
    frequency=12,
)
```

## Step 2 — Day 1: measure the duration gap

Suppose the market discount rate on Day 1 is **4.00 %**.

```{python}
rate_day1 = 0.04

# Asset side
pv_a1 = bond_a.present_value(rate_day1)
pv_b1 = bond_b.present_value(rate_day1)
dur_a1 = bond_a.duration(rate_day1)
dur_b1 = bond_b.duration(rate_day1)
pv_assets1 = pv_a1 + pv_b1

# Liability side
pv_spia1 = spia.present_value(rate_day1)
pv_term1 = term.present_value(rate_day1)
dur_spia1 = spia.duration(rate_day1)
dur_term1 = term.duration(rate_day1)
pv_liab1 = pv_spia1 + pv_term1

# Weighted-average durations
dur_assets1 = (pv_a1 * dur_a1 + pv_b1 * dur_b1) / pv_assets1
dur_liab1 = (pv_spia1 * dur_spia1 + pv_term1 * dur_term1) / pv_liab1
gap1 = dur_assets1 - dur_liab1

day1_df = pl.DataFrame(
    {
        "Section": [
            "Assets",
            "Assets",
            "Assets",
            "Liabilities",
            "Liabilities",
            "Liabilities",
            "Summary",
        ],
        "Item": [
            "Bond A",
            "Bond B",
            "Total",
            "SPIA",
            "Term Life",
            "Total",
            "Duration Gap (A − L)",
        ],
        "PV": [pv_a1, pv_b1, pv_assets1, pv_spia1, pv_term1, pv_liab1, None],
        "Duration": [
            dur_a1,
            dur_b1,
            dur_assets1,
            dur_spia1,
            dur_term1,
            dur_liab1,
            gap1,
        ],
    }
)

(
    GT(day1_df, rowname_col="Item", groupname_col="Section")
    .tab_header(title="Day 1 Portfolio", subtitle=f"Market rate: {rate_day1:.2%}")
    .fmt_currency(columns="PV", decimals=0)
    .fmt_number(columns="Duration", decimals=2)
    .sub_missing(missing_text="")
)
```

The asset portfolio has shorter duration than the liabilities — a
negative duration gap.  If rates fall, liability PV rises faster than
asset PV, eroding surplus.

## Step 3 — Enter a receive-fixed swap to close the gap

A **receive-fixed** swap adds duration: it is economically equivalent
to buying a fixed-rate bond and funding it at the floating rate.

We size the swap notional using **DV01 matching** — the standard
approach for hedging interest-rate risk.  We need the swap's DV01 to
fill the gap between asset DV01 and liability DV01:

$$
\text{Notional} = \frac{\text{DV01}_L - \text{DV01}_A}
                       {\text{DV01}_{\text{swap per \$1 notional}}}
$$

```{python}
# Compute asset and liability DV01s (dollar value of 1 bp)
def dv01(pv_func, rate):
    return (pv_func(rate - 0.0001) - pv_func(rate + 0.0001)) / 2

dv01_a = dv01(bond_a.present_value, rate_day1) + dv01(bond_b.present_value, rate_day1)
dv01_l = dv01(spia.present_value, rate_day1) + dv01(term.present_value, rate_day1)
dv01_gap = dv01_l - dv01_a

# Set up a unit-notional 10-year receive-fixed swap at 4 %
swap_tenor = 10
unit_swap = InterestRateSwap(
    notional=1, fixed_rate=0.04, tenor=swap_tenor,
    frequency=2, pay_fixed=False,
)

# Flat floating forecast equal to the current rate
flat_floating = [rate_day1] * unit_swap.n_periods
dv01_per_dollar = unit_swap.dv01(flat_floating, rate_day1)

swap_notional = dv01_gap / dv01_per_dollar
swap_notional = round(swap_notional / 100_000) * 100_000  # round to $100k

# Create the sized swap
swap = InterestRateSwap(
    notional=swap_notional, fixed_rate=0.04, tenor=swap_tenor,
    frequency=2, pay_fixed=False,
)

dv01_df = pl.DataFrame({
    "Section": ["Assets", "Liabilities", "Gap", "Swap", "Swap"],
    "Metric": ["DV01", "DV01", "DV01 Gap", "DV01 per $1", "Required Notional"],
    "Value": [dv01_a, dv01_l, dv01_gap, dv01_per_dollar, swap_notional],
})

(
    GT(dv01_df, rowname_col="Metric", groupname_col="Section")
    .tab_header(title="DV01 Matching")
    .fmt_number(columns="Value", rows=[0, 1, 2], decimals=2)
    .fmt_number(columns="Value", rows=[3], decimals=10)
    .fmt_currency(columns="Value", rows=[4], decimals=0)
)
```

### Hedged portfolio on Day 1

```{python}
pv_swap1 = swap.present_value(flat_floating, rate_day1)
dv01_swap1 = swap.dv01(flat_floating, rate_day1)

# Portfolio duration including the swap's duration contribution
# Swap duration contribution = swap DV01 * 10000 / PV_assets (approx)
dur_hedged1 = dur_assets1 + (swap.dv01(flat_floating, rate_day1) * 10_000) / pv_assets1

hedged_df = pl.DataFrame({
    "Section": ["Swap", "Swap", "Duration", "Duration", "Duration"],
    "Metric": ["PV", "DV01", "Hedged Assets", "Liabilities", "Gap"],
    "Value": [pv_swap1, dv01_swap1, dur_hedged1, dur_liab1, dur_hedged1 - dur_liab1],
})

(
    GT(hedged_df, rowname_col="Metric", groupname_col="Section")
    .tab_header(title="Day 1 — Hedged Portfolio")
    .fmt_currency(columns="Value", rows=[0], decimals=0)
    .fmt_number(columns="Value", rows=[1, 2, 3, 4], decimals=2)
)
```

## Step 4 — Day 2: rates move

Overnight the market rate drops by 50 bps to **3.50 %**.

```{python}
rate_day2 = 0.035
flat_floating_day2 = [rate_day2] * swap.n_periods

# Re-value everything at the new rate
pv_a2 = bond_a.present_value(rate_day2)
pv_b2 = bond_b.present_value(rate_day2)
pv_assets2 = pv_a2 + pv_b2

pv_spia2 = spia.present_value(rate_day2)
pv_term2 = term.present_value(rate_day2)
pv_liab2 = pv_spia2 + pv_term2

pv_swap2 = swap.present_value(flat_floating_day2, rate_day2)

surplus_unhedged_d1 = pv_assets1 - pv_liab1
surplus_unhedged_d2 = pv_assets2 - pv_liab2
surplus_hedged_d1 = pv_assets1 + pv_swap1 - pv_liab1
surplus_hedged_d2 = pv_assets2 + pv_swap2 - pv_liab2

day2_df = pl.DataFrame({
    "Metric": ["Day 1", "Day 2", "Change"],
    "Assets": [pv_assets1, pv_assets2, pv_assets2 - pv_assets1],
    "Liabilities": [pv_liab1, pv_liab2, pv_liab2 - pv_liab1],
    "Hedge": [pv_swap1, pv_swap2, pv_swap2 - pv_swap1],
    "Unhedged": [surplus_unhedged_d1, surplus_unhedged_d2, surplus_unhedged_d2 - surplus_unhedged_d1],
    "Hedged": [surplus_hedged_d1, surplus_hedged_d2, surplus_hedged_d2 - surplus_hedged_d1],
})

(
    GT(day2_df, rowname_col="Metric")
    .tab_header(title="Day 2 — Rate Impact", subtitle=f"Market rate: {rate_day2:.2%} (down 50 bps)")
    .tab_spanner(label="Surplus", columns=["Unhedged", "Hedged"])
    .fmt_currency(columns=["Assets", "Liabilities", "Hedge", "Unhedged", "Hedged"], decimals=0)
)
```

## Key takeaways

* **Without the swap**, the 50 bp rate drop causes liabilities to rise
  faster than assets, shrinking surplus.
* **With the receive-fixed swap**, the swap gains value as rates fall,
  offsetting the liability increase and stabilising surplus.
* The swap notional was sized so that the portfolio's duration gap is
  approximately zero — this is classical **duration matching**.
